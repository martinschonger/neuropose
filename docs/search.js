window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pose", "modulename": "pose", "kind": "module", "doc": "<p>Package for creating and working with a neuromorphic model for maintaining three-dimensional pose estimates via attractor dynamics. The representation is updated through neural dynamics according to tangential and angular velocity inputs.</p>\n\n<h6 id=\"example-usage\">Example Usage</h6>\n\n<p>How to run the pose network on the Nengo Loihi backend, with velocity input\ncorresponding to straight movement. We use <a href=\"https://github.com/IDSIA/sacred\">Sacred</a> and a\nMongoDB database for configuration management and organizing simulation results.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">exp</span> <span class=\"kn\">import</span> <span class=\"n\">ex</span>\n\n<span class=\"c1\"># Run the simulation. Specify duration, input commands, and enable the Nengo Loihi backend. All</span>\n<span class=\"c1\"># other parameters get default values as defined in `exp.default_config`.</span>\n<span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">config_updates</span><span class=\"o\">=</span><span class=\"p\">{</span>\n    <span class=\"s1\">&#39;simulation_duration&#39;</span><span class=\"p\">:</span> <span class=\"mf\">5.7</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;input&#39;</span><span class=\"p\">:</span> <span class=\"p\">[{</span>  <span class=\"c1\"># Initialize a pose estimate, specified in reciprocal grid coordinates.</span>\n        <span class=\"s1\">&#39;duration&#39;</span><span class=\"p\">:</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;cmds&#39;</span><span class=\"p\">:</span> <span class=\"p\">[{</span><span class=\"s1\">&#39;cmd&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;input_freq&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;bump_centers&#39;</span><span class=\"p\">:</span> <span class=\"p\">[(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)]}]</span>\n    <span class=\"p\">},</span> <span class=\"p\">{</span>  <span class=\"c1\"># Short period of no movement to allow the attractor network reach a stable state.</span>\n        <span class=\"s1\">&#39;duration&#39;</span><span class=\"p\">:</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;cmds&#39;</span><span class=\"p\">:</span> <span class=\"p\">[{</span><span class=\"s1\">&#39;cmd&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;manual&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;shift_inhib&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;pos_rot_shift_inhib&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;neg_rot_shift_inhib&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}]</span>\n    <span class=\"p\">},</span> <span class=\"p\">{</span>  <span class=\"c1\"># Constant tangential velocity input of 0.5, angular velocity input of 0.</span>\n        <span class=\"s1\">&#39;duration&#39;</span><span class=\"p\">:</span> <span class=\"mf\">5.0</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;cmds&#39;</span><span class=\"p\">:</span> <span class=\"p\">[{</span><span class=\"s1\">&#39;cmd&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;manual_vel&#39;</span><span class=\"p\">,</span>\n                         <span class=\"s1\">&#39;tangential_vel&#39;</span><span class=\"p\">:</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span>\n                         <span class=\"s1\">&#39;angular_vel&#39;</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">}]</span>\n    <span class=\"p\">}],</span>\n    <span class=\"s1\">&#39;use_loihi&#39;</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">});</span>\n</code></pre>\n</div>\n\n<p>The data generated during simulation can be accessed and decoded as follows.\nAssuming defaults for everything, you only need to plug in <code>your_mongo_uri</code>.</p>\n\n<p>The <code>decoders</code> can be obtained as the weights of the main recurrent connection as computed by Nengo. To this end, disable our custom direct neurons-to-neurons connection and enable the NEF-style connection in <code>nengo_utils</code>. Then get the decoders like <code>decoders = sim.data[pose_network.attractor_network.rec_con].weights.copy()</code>. This needs to be done only once. Do not forget to undo the changes in <code>nengo_utils</code> afterwards.</p>\n\n<p>Eventually, we arrive at a set of pose estimates for each time point.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">incense</span>\n<span class=\"kn\">import</span> <span class=\"nn\">nengo</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">exp</span> <span class=\"kn\">import</span> <span class=\"n\">ex</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pose.experiments</span> <span class=\"kn\">import</span> <span class=\"n\">get_cluster_centers_timeseries</span><span class=\"p\">,</span> <span class=\"n\">reconstruct_timeseries</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pose.freq_space</span> <span class=\"kn\">import</span> <span class=\"n\">get_0_coefs</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pose.hex</span> <span class=\"kn\">import</span> <span class=\"n\">fspace_base</span><span class=\"p\">,</span> <span class=\"n\">get_3d_coordinates_unwrapped_vectorized</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pose.nengo_utils</span> <span class=\"kn\">import</span> <span class=\"n\">encoding_mask</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pose.plotting</span> <span class=\"kn\">import</span> <span class=\"n\">plot_experiment_xy</span>\n\n<span class=\"c1\"># Load the experiment&#39;s metadata and data from the database.</span>\n<span class=\"n\">loader</span> <span class=\"o\">=</span> <span class=\"n\">incense</span><span class=\"o\">.</span><span class=\"n\">ExperimentLoader</span><span class=\"p\">(</span>\n    <span class=\"n\">mongo_uri</span><span class=\"o\">=</span><span class=\"n\">your_mongo_uri</span><span class=\"p\">,</span>\n    <span class=\"n\">db_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sacred&#39;</span>\n<span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">load_experiment</span><span class=\"p\">(</span><span class=\"n\">loader</span><span class=\"p\">):</span>\n    <span class=\"n\">exp</span> <span class=\"o\">=</span> <span class=\"n\">loader</span><span class=\"o\">.</span><span class=\"n\">find_latest</span><span class=\"p\">()</span>  <span class=\"c1\"># we want the most recent experiment</span>\n    <span class=\"n\">_config</span> <span class=\"o\">=</span> <span class=\"n\">exp</span><span class=\"o\">.</span><span class=\"n\">to_dict</span><span class=\"p\">()[</span><span class=\"s1\">&#39;config&#39;</span><span class=\"p\">]</span>\n    <span class=\"n\">data_raw</span> <span class=\"o\">=</span> <span class=\"n\">exp</span><span class=\"o\">.</span><span class=\"n\">artifacts</span><span class=\"p\">[</span><span class=\"s1\">&#39;sim_data.pkl&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">as_type</span><span class=\"p\">(</span><span class=\"n\">incense</span><span class=\"o\">.</span><span class=\"n\">artifact</span><span class=\"o\">.</span><span class=\"n\">PickleArtifact</span><span class=\"p\">)</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">data_raw</span><span class=\"o\">.</span><span class=\"n\">render</span><span class=\"p\">()</span>  <span class=\"c1\"># load pickle</span>\n    <span class=\"k\">return</span> <span class=\"n\">exp</span><span class=\"o\">.</span><span class=\"n\">to_dict</span><span class=\"p\">(),</span> <span class=\"n\">_config</span><span class=\"p\">,</span> <span class=\"n\">data</span>\n<span class=\"n\">_exp_info</span><span class=\"p\">,</span> <span class=\"n\">_config</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">load_experiment</span><span class=\"p\">(</span><span class=\"n\">loader</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Get some config values.</span>\n<span class=\"n\">variance_pose</span> <span class=\"o\">=</span> <span class=\"n\">_config</span><span class=\"p\">[</span><span class=\"s1\">&#39;variance_pose&#39;</span><span class=\"p\">]</span>\n<span class=\"n\">cov</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">eye</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">variance_pose</span>\n<span class=\"n\">fgrid_shape</span> <span class=\"o\">=</span> <span class=\"n\">_config</span><span class=\"p\">[</span><span class=\"s1\">&#39;fgrid_shape&#39;</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># For each time point, decode the neuron activations into representational space.</span>\n<span class=\"n\">decoded_sim_data</span> <span class=\"o\">=</span> <span class=\"n\">decoders</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">&#39;pose_network.output&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">())</span>\n<span class=\"n\">decoded_sim_data</span> <span class=\"o\">=</span> <span class=\"n\">decoded_sim_data</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Reintroduce the ommitted imaginary parts of the Nyquist terms.</span>\n<span class=\"n\">output_restored</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"n\">decoded_sim_data</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">prod</span><span class=\"p\">(</span><span class=\"n\">fgrid_shape</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"n\">output_restored</span><span class=\"p\">[:,</span> <span class=\"n\">encoding_mask</span><span class=\"p\">(</span><span class=\"n\">fgrid_shape</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">()]</span> <span class=\"o\">=</span> <span class=\"n\">decoded_sim_data</span>\n\n<span class=\"c1\"># Undo normalization to obtain the final reciprocal space representation.</span>\n<span class=\"n\">gauss0_f_cropped_flat</span> <span class=\"o\">=</span> <span class=\"n\">get_0_coefs</span><span class=\"p\">(</span><span class=\"n\">fgrid_shape</span><span class=\"p\">,</span> <span class=\"n\">cov</span><span class=\"p\">)</span>\n<span class=\"n\">fact</span> <span class=\"o\">=</span> <span class=\"n\">gauss0_f_cropped_flat</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">/</span> <span class=\"n\">gauss0_f_cropped_flat</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"n\">output_restored</span><span class=\"p\">[:,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">output_restored</span><span class=\"p\">[:,</span> <span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">fact</span>\n\n<span class=\"c1\"># Back-transform into real space.</span>\n<span class=\"n\">pose_reconstructed</span> <span class=\"o\">=</span> <span class=\"n\">reconstruct_timeseries</span><span class=\"p\">(</span><span class=\"n\">output_restored</span><span class=\"p\">,</span> <span class=\"n\">fgrid_shape</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Compute pose estimates from their 3D-Gaussian representation.</span>\n<span class=\"n\">bump_centers</span> <span class=\"o\">=</span> <span class=\"n\">get_cluster_centers_timeseries</span><span class=\"p\">(</span><span class=\"n\">pose_reconstructed</span><span class=\"p\">,</span> <span class=\"n\">fgrid_shape</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Plot the projection of the pose estimates along the third axis, color-coded by time.</span>\n<span class=\"n\">plot_experiment_xy</span><span class=\"p\">(</span><span class=\"n\">_exp_info</span><span class=\"p\">,</span> <span class=\"n\">_config</span><span class=\"p\">,</span> <span class=\"n\">bump_centers</span><span class=\"p\">,</span> <span class=\"n\">time_slice</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">s_</span><span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">:])</span>\n</code></pre>\n</div>\n\n<p><br/></p>\n\n<h6 id=\"note\">Note</h6>\n\n<p>This documentation has been generated by:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pdoc pose exp.py -o ./docs --docformat google --math\n</code></pre>\n</div>\n\n<p><br/></p>\n\n<p>Copyright \u00a9 2023 Martin Schonger <br />\nThis software is licensed under the GPLv3.</p>\n\n<p>The content in <a href=\"pose/fonts\">pose/fonts</a> is licensed under the GPLv3 with copyright belonging to\nthe authors listed in <a href=\"pose/fonts/AUTHORS\">pose/fonts/AUTHORS</a> and <a href=\"pose/fonts/CREDITS\">pose/fonts/CREDITS</a>.</p>\n"}, {"fullname": "pose.experiments", "modulename": "pose.experiments", "kind": "module", "doc": "<p>Run experiments and reconstruct pose estimates from reciprocal representations.</p>\n"}, {"fullname": "pose.experiments.run_experiment", "modulename": "pose.experiments", "qualname": "run_experiment", "kind": "function", "doc": "<p>Runs a simulation for the given config dict.\nComputes the connection weights, sets up the pose network, prepares the input, runs the\nsimulation, and constructs an output dict.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>_config:</strong>  Dict of parameters for the network setup, simulation, etc.\n(see <code>exp.default_config</code> for supported config parameters and sensible defaults)</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Dict of recorded simulation data.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_config</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.reconstruct_timeseries", "modulename": "pose.experiments", "qualname": "reconstruct_timeseries", "kind": "function", "doc": "<p>Reconstructs the real-space representation for each time step from the respective flattened\nFourier coefficient vector.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Array of flattened Fourier coefficient vectors as e.g. decoded from a Nengo\nsimulation.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array of three-dimensional snapshots of the real-space pose domain.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_cluster_centers", "modulename": "pose.experiments", "qualname": "get_cluster_centers", "kind": "function", "doc": "<p>Computes the pose estimates from a snapshot of the real-space pose domain sampled at\ndiscrete points.\nThe number of pose estimates is variable and may even be zero. Data points are separated via\nclustering. Each pose estimate is then obtained as weighted average of the points in it's\ncluster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Sampled real-space pose volume. Shape <code>(*grid_shape)</code>.</li>\n<li><strong>coords_freq_space:</strong>  Coordinates in reciprocal space corresponding to the real-space sample\npoints.</li>\n<li><strong>dist_mat:</strong>  Matrix of pairwise distances between the sample points in real space.</li>\n<li><strong>threshold:</strong>  Fraction of the maximum value in the input data that points need to have in order\nto be considered for clustering.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array of pose estimates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">coords_freq_space</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">dist_mat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span> <span class=\"o\">=</span> <span class=\"mf\">0.4</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_cluster_centers_timeseries", "modulename": "pose.experiments", "qualname": "get_cluster_centers_timeseries", "kind": "function", "doc": "<p>Computes the pose estimates for multiple time points, each given as real-space pose volume\nsampled at a hexagonal grid.\nThe number of pose estimates may be different for each time point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Array of sampled real-space pose volumes.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List of array of pose estimates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_time_array", "modulename": "pose.experiments", "qualname": "get_time_array", "kind": "function", "doc": "<p>Computes the start and stop time points for a list of input commands with individual\ndurations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  List of input commands.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array of start and stop time points.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"nb\">input</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_naive_pose_est_abelian", "modulename": "pose.experiments", "qualname": "get_naive_pose_est_abelian", "kind": "function", "doc": "<p>Get a single pose estimate per time point as the location of the maximum value in the\nrespective sampled three-dimensional pose volume.</p>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>Deprecated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">fourier_generators</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_gauss_freq_optimized", "modulename": "pose.experiments", "qualname": "get_gauss_freq_optimized", "kind": "function", "doc": "<p>Returns a function that shifts a given vector of Fourier coefficients by a given displacement\nvector in three-dimensional frequency space. Uses a rotation matrix.</p>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>Deprecated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid_shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_gauss_pose_est_freq_optimized", "modulename": "pose.experiments", "qualname": "get_gauss_pose_est_freq_optimized", "kind": "function", "doc": "<p>For each time point, fits a <em>single</em> three-dimensional Gaussian (<code>get_gauss_freq_optimized</code>)\nto the respective discretized pose volume and estimates the current pose as the Gaussian's mean.\nFor efficiency, the function fitting is done purely in frequency space.</p>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>Deprecated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">grid_shape</span>, </span><span class=\"param\"><span class=\"n\">initial_guesses_mean</span>, </span><span class=\"param\"><span class=\"n\">initial_guess_var</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_gauss_freq2", "modulename": "pose.experiments", "qualname": "get_gauss_freq2", "kind": "function", "doc": "<p>Returns a function that computes the vector of Fourier coefficients corresponding to two\nthree-dimensional Gaussians given by their mean, variance and scaling factor. Uses rotation\nmatrices.</p>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>Deprecated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid_shape</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.experiments.get_gauss_pose_est_freq2", "modulename": "pose.experiments", "qualname": "get_gauss_pose_est_freq2", "kind": "function", "doc": "<p>For each time point, fits two individually-scaled three-dimensional Gaussians\n(<code>get_gauss_freq2</code>) to the respective discretized pose volume and estimates <em>up to two</em> current\nposes as the Gaussians' means. The function fitting is done real space.</p>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>Deprecated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">grid_shape</span>, </span><span class=\"param\"><span class=\"n\">num_bumps</span>, </span><span class=\"param\"><span class=\"n\">initial_guesses_mean</span>, </span><span class=\"param\"><span class=\"n\">initial_guess_var</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space", "modulename": "pose.freq_space", "kind": "module", "doc": "<p>Construct and manipulate representations in reciprocal space.</p>\n"}, {"fullname": "pose.freq_space.get_fftn_freqs", "modulename": "pose.freq_space", "qualname": "get_fftn_freqs", "kind": "function", "doc": "<p>Compute the frequency bin centers in cycles per unit of the sample spacing.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Frequencies associated with the individual Fourier coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space.get_rotation_matrix", "modulename": "pose.freq_space", "qualname": "get_rotation_matrix", "kind": "function", "doc": "<p>Computes a rotation matrix for a x,y,z-rotation in reciprocal space.</p>\n\n<p>The vectors to be rotated are expected in flattened complex space (see <code>flatten_coefs</code>).</p>\n\n<p>For example, we can shift the center of the Gaussian around by applying such a rotation matrix\nto the coefficients.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n<li><strong>shift:</strong>  Shift vector in reciprocal space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A square rotation matrix <code>R</code>, satisfying <code>R.T = inv(R)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">shift</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space.flatten_coefs", "modulename": "pose.freq_space", "qualname": "flatten_coefs", "kind": "function", "doc": "<p>Transforms Fourier coefficients into flattened complex space, i.e. flattened dimensions and\ninterleaved real and imaginary parts.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coefs:</strong>  Fourier coefficients.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Interleaved real and imaginary parts of Fourier coefficients. Shape <code>(coefs.size*2,)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefs</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">complex128</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space.unflatten_coefs", "modulename": "pose.freq_space", "qualname": "unflatten_coefs", "kind": "function", "doc": "<p>Transforms Fourier coefficients from flattened complex space (see <code>flatten_coefs</code>) into\ncomplex space.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coefs:</strong>  Fourier coefficients in flattened complex space.</li>\n<li><strong>fgrid_shape:</strong>  Desired final shape of the returned array. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Fourier coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefs</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">complex128</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space.get_nyquist_mask", "modulename": "pose.freq_space", "qualname": "get_nyquist_mask", "kind": "function", "doc": "<p>Computes an index mask to omit the imaginary part of Fourier coefficients where the index along\nany axes is 0 or the index is half of the axis-length. For dimensions of even length these\ncorrespond to the Nyquist terms.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Index mask. Shape <code>(np.prod(fgrid_shape)*2,)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">bool_</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space.fftn_hex", "modulename": "pose.freq_space", "qualname": "fftn_hex", "kind": "function", "doc": "<p>Compute the multidimensional FFT on the hexagonal lattice.</p>\n\n<p>In particular, account for the reduced domain of <code>sqrt(3)/2</code> along the y-axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Sampled volume data in real space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Fourier coefficients.</p>\n</blockquote>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>The regular FFT assumes orthogonal axes. We have to account for the relative deviation\n  from a $\\mathbb{Z}^3$ grid. This amounts to a multiplication by the product of the domain\n  extents in all dimensions. In particular, the rectified input to the FFT has an extent of\n  <code>sqrt(3)/2</code> in the y-dimension and, therefore, we effectively multiply the regular FFT\n  output by this value.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">complex128</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space.ifftn_hex", "modulename": "pose.freq_space", "qualname": "ifftn_hex", "kind": "function", "doc": "<p>Compute the multidimensional inverse FFT on the reciprocal hexagonal lattice.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Fourier coefficients.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Volume data in real space.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">complex128</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.freq_space.get_0_coefs", "modulename": "pose.freq_space", "qualname": "get_0_coefs", "kind": "function", "doc": "<p>Compute the Fourier coefficients of a three-dimensional Gaussian bump centered at the origin\nand sampled on the unit cell.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n<li><strong>cov:</strong>  Covariance matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Flattened Fourier coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">cov</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex", "modulename": "pose.hex", "kind": "module", "doc": "<p>Construct and work with the unit domain (rhombic prism), hexagonal grids and corresponding distance\nmatrices. Provides functionality to wrap poses into the rhombic area or conceptually unroll it, as\nwell as to convert between representations with rectangular and rhombic bases.</p>\n"}, {"fullname": "pose.hex.fspace_base", "modulename": "pose.hex", "qualname": "fspace_base", "kind": "variable", "doc": "<p>Basis vectors of the reciprocal space or, equivalently, transformation matrix from reciprocal\nspace to real space.</p>\n", "default_value": " = array([[1.       , 0.5      , 0.       ],\n       [0.       , 0.8660254, 0.       ],\n       [0.       , 0.       , 1.       ]])"}, {"fullname": "pose.hex.inv_fspace_base", "modulename": "pose.hex", "qualname": "inv_fspace_base", "kind": "variable", "doc": "<p>Basis vectors of the real space in reciprocal space or, equivalently, transformation matrix from\nreal space to reciprocal space.</p>\n", "default_value": " = array([[ 1.        , -0.57735027,  0.        ],\n       [ 0.        ,  1.15470054,  0.        ],\n       [ 0.        ,  0.        ,  1.        ]])"}, {"fullname": "pose.hex.get_domain", "modulename": "pose.hex", "qualname": "get_domain", "kind": "function", "doc": "<p>Provide the domain of the unit cell of the hexagonal Bravais lattice.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Domain extent in all dimensions. Shape <code>(3,)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.polar_to_cartesian", "modulename": "pose.hex", "qualname": "polar_to_cartesian", "kind": "function", "doc": "<p>Convert polar coordinates in the x-y plane to three-dimensional Cartesian coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>r:</strong>  Radius.</li>\n<li><strong>theta:</strong>  Angle in radian.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Cartesian coordinates with z-component of 0.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">theta</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.get_3d_coordinates", "modulename": "pose.hex", "qualname": "get_3d_coordinates", "kind": "function", "doc": "<p>Computes the coordinates of lattice points in the unit cell wrapped into a rectangular\ncuboid.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of the lattice of the unit cell.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate arrays for each dimension, which contain points in their order of appearance in\n  the rectangular cuboid.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.get_2d_distances", "modulename": "pose.hex", "qualname": "get_2d_distances", "kind": "function", "doc": "<p>Computes the signed pairwise distances between all points in the unit cell of a\ntwo-dimensional hexagonal Bravais lattice, wrapped into a rectangle. Parts adapted from 'Build_grid_cells.ipynb' in <a href=\"https://github.com/DiogoSantosPata/gridcells\">https://github.com/DiogoSantosPata/gridcells</a>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of the unit cell of a compatible three-dimensional lattice.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A tuple <code>(u_diff, v_diff)</code>, where <code>u_diff</code> contains the signed pairwise distances\n  between lattice points in x-dimension (<code>u_diff[i,j]</code> points from point <code>i</code> to\n  point <code>j</code> (projected onto x)), and <code>v_diff</code> contains the analogous information for the\n  y-dimension.</p>\n</blockquote>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p><code>np.sqrt(u_diff**2 + v_diff**2)</code> gives the pairwise absolute distances between points.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.get_3d_distances", "modulename": "pose.hex", "qualname": "get_3d_distances", "kind": "function", "doc": "<p>Computes the signed pairwise distances between all points in the unit cell of a\nthree-dimensional hexagonal Bravais lattice, wrapped into a rectangular cuboid.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of the unit cell of the lattice.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A tuple <code>(u_diff, v_diff, w_diff)</code>, where <code>u_diff</code> contains the signed pairwise\n  distances between lattice points in x-dimension (<code>u_diff[i,j]</code> points from point <code>i</code> to\n  point <code>j</code> (projected onto x)), <code>v_diff</code> and <code>w_diff</code> contain the analogous information\n  for the y- and z-axis, respectively.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.get_3d_distances_unwrapped", "modulename": "pose.hex", "qualname": "get_3d_distances_unwrapped", "kind": "function", "doc": "<p>Computes the signed pairwise distances between all points in the unit cell of a\nthree-dimensional hexagonal Bravais lattice.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of the unit cell of the lattice.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A tuple <code>(u_diff, v_diff, w_diff)</code>, where <code>u_diff</code> contains the signed pairwise\n  distances between lattice points in x-dimension (<code>u_diff[i,j]</code> points from point <code>i</code> to\n  point <code>j</code> (projected onto x)), <code>v_diff</code> and <code>w_diff</code> contain the analogous information\n  for the y- and z-axis, respectively.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.unwrap_single", "modulename": "pose.hex", "qualname": "unwrap_single", "kind": "function", "doc": "<p>Unwraps data from the wrapped unit cell to the regular unit cell.</p>\n\n<p>If <code>dim &gt; 1</code>, assumes that the individual data points correspond to coordinates on the lattice\n(<code>dim = 3</code>) and corrects the z-dimension of these coordinates accordingly.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>wrapped_data:</strong>  Data corresponding to and arranged like points in the wrapped unit cell.</li>\n<li><strong>grid_shape:</strong>  Shape of the unit cell of the lattice.</li>\n<li><strong>dim:</strong>  Dimension of a single data point.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Data corresponding to points in the regular unit cell.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">wrapped_data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.unwrap_multi", "modulename": "pose.hex", "qualname": "unwrap_multi", "kind": "function", "doc": "<p>Unwraps data specified for each point in the wrapped unit cell, where for each point the data\namounts in turn to a data point for all points in the wrapped unit cell, to the regular unit\ncell (on two levels).</p>\n\n<p>If <code>dim &gt; 1</code>, assumes that the individual data points correspond to coordinates on the lattice\n(<code>dim = 3</code>) and corrects the z-dimension of these coordinates accordingly.</p>\n\n<p>Uses <code>unwrap_single</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>wrapped_data:</strong>  Data corresponding to and arranged like points in the wrapped unit cell, on\ntwo levels.</li>\n<li><strong>grid_shape:</strong>  Shape of the unit cell of the lattice.</li>\n<li><strong>dim:</strong>  Dimension of a single data point.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Data corresponding to points in the regular unit cell, on two levels.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">wrapped_data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.get_3d_coordinates_unwrapped", "modulename": "pose.hex", "qualname": "get_3d_coordinates_unwrapped", "kind": "function", "doc": "<p>Computes the coordinates of lattice points in the unit cell of a three-dimensional hexagonal\nBravais lattice.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>generators:</strong>  Primitive translation vectors of the primitive unit cell of the lattice.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array of coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">generators</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.get_3d_coordinates_unwrapped_vectorized", "modulename": "pose.hex", "qualname": "get_3d_coordinates_unwrapped_vectorized", "kind": "function", "doc": "<p>Wrapper of <code>get_3d_coordinates_unwrapped</code> that returns coordinate arrays in vectorized\nformat.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>generators:</strong>  Primitive translation vectors of the primitive unit cell of the lattice.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate arrays for each dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">generators</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.wrap_closer", "modulename": "pose.hex", "qualname": "wrap_closer", "kind": "function", "doc": "<p>Wraps points as close as possible to a reference point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ref_point:</strong>  Reference point in reciprocal space to which the points should be wrapped close.</li>\n<li><strong>points:</strong>  Points to wrap in reciprocal space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array of wrapped points in reciprocal space.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ref_point</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.hex.wrap_into_parallelogram", "modulename": "pose.hex", "qualname": "wrap_into_parallelogram", "kind": "function", "doc": "<p>Wraps points into the unit cell of a three-dimensional hexagonal Bravais lattice.</p>\n\n<p>Assumes all values are in the range -1 to 2.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points:</strong>  Points to wrap in reciprocal space.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Wrapped points in reciprocal space.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.input", "modulename": "pose.input", "kind": "module", "doc": "<p>Generation and preprocessing of input data, conversion between velocities and inhibition values, as\nwell as trajectory-related functions.</p>\n"}, {"fullname": "pose.input.func_to_fit3", "modulename": "pose.input", "qualname": "func_to_fit3", "kind": "function", "doc": "<p>Generic 3rd-order bivariate polynomial function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">d</span>, </span><span class=\"param\"><span class=\"n\">e</span>, </span><span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">g</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.coefs_shift_inhib", "modulename": "pose.input", "qualname": "coefs_shift_inhib", "kind": "variable", "doc": "<p>Coefficients for computing shift inhibition from velocity with <code>func_to_fit3</code>, as obtained by\nfitting hand-labeled simulation data, where all edgecases are included and outliers removed.</p>\n", "default_value": " = array([-5.12789881,  1.63221362, -0.364301  ,  0.06376009, -0.00529229,\n        0.01347963, -0.00594336])"}, {"fullname": "pose.input.coefs_rotation_inhib", "modulename": "pose.input", "qualname": "coefs_rotation_inhib", "kind": "variable", "doc": "<p>Coefficients for computing rotation inhibition from velocity with <code>func_to_fit3</code>, as obtained by\nfitting hand-labeled simulation data, where all edgecases are included and outliers removed.</p>\n", "default_value": " = array([ 2.24429458, -0.83483308,  0.0996706 ,  0.06562274, -0.02284753,\n        0.04700435, -0.06818754])"}, {"fullname": "pose.input.max_tang_vel", "modulename": "pose.input", "qualname": "max_tang_vel", "kind": "variable", "doc": "<p>Maximum tangential velocity that can be represented by the pose network. Valid for any angular\nvelocity up to <code>max_abs_ang_vel</code>.</p>\n", "default_value": " = 0.223"}, {"fullname": "pose.input.max_abs_ang_vel", "modulename": "pose.input", "qualname": "max_abs_ang_vel", "kind": "variable", "doc": "<p>Maximum absolute angular velocity that can be represented by the pose network. Valid for any\ntangential velocity up to <code>max_tang_vel</code>.</p>\n", "default_value": " = 1.256"}, {"fullname": "pose.input.preprocess_tang_vel", "modulename": "pose.input", "qualname": "preprocess_tang_vel", "kind": "function", "doc": "<p>Crops the tangential velocity to the range [0, <code>max_tang_vel</code>].</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tang_vel:</strong>  Scalar or array of tangential velocities.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Scalar or array of cropped tangential velocities.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tang_vel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.preprocess_ang_vel", "modulename": "pose.input", "qualname": "preprocess_ang_vel", "kind": "function", "doc": "<p>Crops the angular velocity to the range [-<code>max_abs_ang_vel</code>, <code>max_abs_ang_vel</code>].</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ang_vel:</strong>  Scalar or array of angular velocities.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Scalar or array of cropped angular velocities.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ang_vel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.vel_to_shift_inhib", "modulename": "pose.input", "qualname": "vel_to_shift_inhib", "kind": "function", "doc": "<p>Computes shift inhibition from tangential and angular velocity using <code>func_to_fit3</code>\nparameterized by <code>coefs_shift_inhib</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tangential_vel:</strong>  Scalar tangential velocity. Will be preprocessed by <code>preprocess_tang_vel</code>.</li>\n<li><strong>angular_vel:</strong>  Scalar angular velocity. Will be preprocessed by <code>preprocess_ang_vel</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Inhibition value, lower-bounded by 0, mapped to 1 if larger than 0.0637.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tangential_vel</span>, </span><span class=\"param\"><span class=\"n\">angular_vel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.vel_to_ccw_inhib", "modulename": "pose.input", "qualname": "vel_to_ccw_inhib", "kind": "function", "doc": "<p>Computes inhibition for counter-clockwise rotation from tangential and angular velocity using\n<code>func_to_fit3</code> parameterized by <code>coefs_rotation_inhib</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tangential_vel:</strong>  Scalar tangential velocity. Will be preprocessed by <code>preprocess_tang_vel</code>.</li>\n<li><strong>angular_vel:</strong>  Scalar angular velocity. Will be preprocessed by <code>preprocess_ang_vel</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Inhibition value, lower-bounded by 0, mapped to 1 if larger than 0.0656 or if the angular\n  velocity is <em>less</em> than or equal to 0.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tangential_vel</span>, </span><span class=\"param\"><span class=\"n\">angular_vel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.vel_to_cw_inhib", "modulename": "pose.input", "qualname": "vel_to_cw_inhib", "kind": "function", "doc": "<p>Computes inhibition for clockwise rotation from tangential and angular velocity using\n<code>func_to_fit3</code> parameterized by <code>coefs_rotation_inhib</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tangential_vel:</strong>  Scalar tngential velocity. Will be preprocessed by <code>preprocess_tang_vel</code>.</li>\n<li><strong>angular_vel:</strong>  Scalar angular velocity. Will be preprocessed by <code>preprocess_ang_vel</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Inhibition value, lower-bounded by 0, mapped to 1 if larger than 0.0656 or if the angular\n  velocity is <em>greater</em> than or equal to 0.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tangential_vel</span>, </span><span class=\"param\"><span class=\"n\">angular_vel</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.preprocess_input_list", "modulename": "pose.input", "qualname": "preprocess_input_list", "kind": "function", "doc": "<p>Brings the input command list to a standard format with at most one tangential and angular\nvelocity pair per command.\nDirectly modifies the input argument.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input:</strong>  List of commands.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">input</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.input.cmds_to_input_values", "modulename": "pose.input", "qualname": "cmds_to_input_values", "kind": "function", "doc": "<p>Converts a list of abstract commands to a single dictionary containing a more concrete input\nrepresentation.</p>\n\n<p>For example, bump centers are combined and converted to input values for each neuron.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cmds:</strong>  List of commands to be applied at a time step.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n<li><strong>gauss0_f_cropped_flat:</strong>  Fourier coefficients of a Gaussian centered at the origin.</li>\n<li><strong>encoders:</strong>  Encoders of the attractor network.</li>\n<li><strong>scale_fact:</strong>  Scale factor that has been applied to the encoders, most likely during</li>\n<li>normalization.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>NotImplementedError:</strong>  If a currently unsupported command is used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Dictionary containing near-final input for the path integration network.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cmds</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">gauss0_f_cropped_flat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">encoders</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">scale_fact</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.input.cmd_list_to_inhib_values", "modulename": "pose.input", "qualname": "cmd_list_to_inhib_values", "kind": "function", "doc": "<p>Returns a helper function that extracts inputs from a list of command lists given a time\npoint.\nSee source code for documentation of the returned function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cmds:</strong>  Essentially a list of command lists, where each command list is associated with a time</li>\n<li>point at which it is to take effect.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n<li><strong>gauss0_f_cropped_flat:</strong>  Fourier coefficients of a Gaussian centered at the origin.</li>\n<li><strong>encoders:</strong>  Encoders of the attractor network.</li>\n<li><strong>scale_fact:</strong>  Scale factor that has been applied to the encoders, most likely during</li>\n<li>normalization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p><code>cmd_list_to_input_values</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cmds</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">gauss0_f_cropped_flat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">encoders</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">scale_fact</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span></span><span class=\"return-annotation\">) -> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">],</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.input.get_circ_traj", "modulename": "pose.input", "qualname": "get_circ_traj", "kind": "function", "doc": "<p>Generate waypoints of circular trajectory with given radius.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">radian_per_second</span>, </span><span class=\"param\"><span class=\"n\">center</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">])</span>, </span><span class=\"param\"><span class=\"n\">phase_shift</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.traj_to_inhib", "modulename": "pose.input", "qualname": "traj_to_inhib", "kind": "function", "doc": "<p>Convert an array of waypoints to an array of modulation values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>waypoints:</strong>  Positions <code>(x,y)</code> at each time step. Shape <code>(T,2)</code>, where <code>T</code> is the number\nof time steps.</li>\n<li><strong>initial_orientation:</strong>  Heading angle at <code>t=0</code>. Defaults to 0.0.</li>\n<li><strong>dt:</strong>  Time in seconds in which the next position needs to be reached. Defaults to 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Modulation values for the shift and rotation inhibition nodes. Shape <code>(T,3)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">waypoints</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">initial_orientation</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.input.delta_to_inhib", "modulename": "pose.input", "qualname": "delta_to_inhib", "kind": "function", "doc": "<p>Convert a combination of space delta and dt to an array of modulation values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>delta:</strong>  Vector from the current position to the target position. Shape <code>(2,)</code>.</li>\n<li><strong>initial_orientation:</strong>  Heading angle in radians before applying delta.</li>\n<li><strong>dt:</strong>  Time in seconds in which the next position needs to be reached. Defaults to 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Modulation values for the shift inhibition node, and two the rotation inhibition nodes.\n  Shape <code>(3,)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">initial_orientation</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.delta_to_velocities", "modulename": "pose.input", "qualname": "delta_to_velocities", "kind": "function", "doc": "<p>Convert a combination of space delta and dt to an array of tangential and angular velocities.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>delta:</strong>  Vector from the current position to the target position. Shape <code>(2,)</code>.</li>\n<li><strong>initial_orientation:</strong>  Heading angle in radians before applying delta.</li>\n<li><strong>dt:</strong>  Time in seconds in which the next position needs to be reached. Defaults to 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tangential and angular velocities. Shape <code>(2,)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">initial_orientation</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.input.traj_to_velocities", "modulename": "pose.input", "qualname": "traj_to_velocities", "kind": "function", "doc": "<p>Converts an array of waypoints to an array of tangential and angular velocities.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>waypoints:</strong>  Positions <code>(x,y)</code> at each time step. Shape <code>(T,2)</code>, where <code>T</code> is the number\nof time steps.</li>\n<li><strong>initial_orientation:</strong>  Heading angle at <code>t=0</code>. Defaults to 0.0.</li>\n<li><strong>dt:</strong>  Time in seconds in which the next position needs to be reached. Defaults to 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array of tangential and angular values. Shape <code>(T,2)</code>.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">waypoints</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">initial_orientation</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.input.velocities_to_traj", "modulename": "pose.input", "qualname": "velocities_to_traj", "kind": "function", "doc": "<p>Converts an array of tangential and angular velocities to an array of waypoints.\nEssentially integrates the change caused by the instantaneous velocities over time.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tang_vels:</strong>  Array of tangential velocities, one value for each time step.</li>\n<li><strong>ang_vels:</strong>  Array of angular velocities, one value for each time step.</li>\n<li><strong>starting_point:</strong>  <code>(x,y)</code> position at <code>t=0</code>.</li>\n<li><strong>initial_orientation:</strong>  Heading angle at <code>t=0</code>.</li>\n<li><strong>dt:</strong>  Time in seconds between two consecutive data points. Can be an array or scalar.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array of waypoints.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tang_vels</span>, </span><span class=\"param\"><span class=\"n\">ang_vels</span>, </span><span class=\"param\"><span class=\"n\">starting_point</span>, </span><span class=\"param\"><span class=\"n\">initial_orientation</span>, </span><span class=\"param\"><span class=\"n\">dt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils", "modulename": "pose.io_utils", "kind": "module", "doc": "<p>File I/O and communication with database for running, logging, and evaluating experiments.</p>\n\n<h6 id=\"note\">Note:</h6>\n\n<blockquote>\n  <p>Not part of the public API.</p>\n</blockquote>\n"}, {"fullname": "pose.io_utils.get_mem_info", "modulename": "pose.io_utils", "qualname": "get_mem_info", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.get_pose_lib_path", "modulename": "pose.io_utils", "qualname": "get_pose_lib_path", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.get_debug_path", "modulename": "pose.io_utils", "qualname": "get_debug_path", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.datetime_to_str", "modulename": "pose.io_utils", "qualname": "datetime_to_str", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ts</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.get_mongo_uri", "modulename": "pose.io_utils", "qualname": "get_mongo_uri", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">db</span><span class=\"o\">=</span><span class=\"s1\">&#39;default&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.get_git_revision_hash", "modulename": "pose.io_utils", "qualname": "get_git_revision_hash", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.get_git_revision_short_hash", "modulename": "pose.io_utils", "qualname": "get_git_revision_short_hash", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.append_list_as_row", "modulename": "pose.io_utils", "qualname": "append_list_as_row", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span>, </span><span class=\"param\"><span class=\"n\">list_of_elem</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.append_dict_as_row", "modulename": "pose.io_utils", "qualname": "append_dict_as_row", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span>, </span><span class=\"param\"><span class=\"n\">dict_of_elem</span>, </span><span class=\"param\"><span class=\"n\">field_names</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.log_experiment", "modulename": "pose.io_utils", "qualname": "log_experiment", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">timestamp</span>, </span><span class=\"param\"><span class=\"n\">exp_dict</span>, </span><span class=\"param\"><span class=\"n\">csv_header</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.io_utils.send_mail", "modulename": "pose.io_utils", "qualname": "send_mail", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">subject</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils", "modulename": "pose.nengo_utils", "kind": "module", "doc": "<p>Define the entire pose network as a Nengo structure, including encoders and connection weights.</p>\n"}, {"fullname": "pose.nengo_utils.mex_hat", "modulename": "pose.nengo_utils", "qualname": "mex_hat", "kind": "function", "doc": "<p>Computes a mexican hat function at the specified locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x:</strong>  Points for evaluating the Gaussians.</li>\n<li><strong>var_exc:</strong>  Variance of the excitatory Gaussian.</li>\n<li><strong>var_inh:</strong>  Variance of the inhibitory Gaussian.</li>\n<li><strong>fact_exc:</strong>  Scaling factor of the excitatory Gaussian.</li>\n<li><strong>fact_inh:</strong>  Scaling factor of the inhibitory Gaussian.</li>\n<li><strong>offset:</strong>  Constant global offset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Function values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">__nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">var_exc</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">var_inh</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">fact_exc</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">fact_inh</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.encoding_len", "modulename": "pose.nengo_utils", "qualname": "encoding_len", "kind": "function", "doc": "<p>Computes the final number of representational dimensions based on the index mask.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Number of representational dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.encoding_mask", "modulename": "pose.nengo_utils", "qualname": "encoding_mask", "kind": "function", "doc": "<p>Generates an indexing mask for the flattened Fourier coefficient vector to exclude certain\ndimensions, e.g. the imaginary part of the Nyquist terms.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Flat index mask.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.rotate_to_grid", "modulename": "pose.nengo_utils", "qualname": "rotate_to_grid", "kind": "function", "doc": "<p>Propagates a base Fourier coefficient vector to all grid points via rotation in reciprocal\nspace.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coefs:</strong>  Base Fourier coefficients for position <code>(0,0,0)</code>.</li>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A four-dimensional array where the first three dimensions index the grid points, and the\n  last dimension corresponds to the Fourier coefficients.</p>\n</blockquote>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>By exploiting the grid structure and NumPy's vectorization this function is very efficient.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefs</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.get_encoders", "modulename": "pose.nengo_utils", "qualname": "get_encoders", "kind": "function", "doc": "<p>Computes encoders as modified Fourier coefficient vectors of three-dimensional Gaussians.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n<li><strong>cov:</strong>  Covariance matrix of the Gaussian.</li>\n<li><strong>normalize:</strong>  Whether to normalize the final encoder vectors to unit length. Defaults to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Array with the encoder vectors as rows.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">cov</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">normalize</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.shift_weights_vect_optimized", "modulename": "pose.nengo_utils", "qualname": "shift_weights_vect_optimized", "kind": "function", "doc": "<p>Applies a constant shift vector to a set of Fourier coefficients.</p>\n\n<p>The computation is performed in reciprocal space.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>base_coefs_on_grid:</strong>  Un-shifted Fourier coefficient vectors at each grid point.</li>\n<li><strong>shift_vec:</strong>  Shift vector.</li>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Shifted weight matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">base_coefs_on_grid</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">shift_vec</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.shift_weights_angle_optimized", "modulename": "pose.nengo_utils", "qualname": "shift_weights_angle_optimized", "kind": "function", "doc": "<p>Shifts a set of Fourier coefficients based on the preferred orientation angle as specified by\nthe associated z-coordinates. Consequently, the base coefficients are shifted differently in\neach z-plane.</p>\n\n<p>The computation is performed in reciprocal space.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>base_coefs_on_grid:</strong>  Un-shifted Fourier coefficient vectors at each grid point.</li>\n<li><strong>shift:</strong>  Shift value indicating how far the weights should be shifted along the preferred</li>\n<li>direction of the individual z-planes.</li>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Transformed weight matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">base_coefs_on_grid</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">shift</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.get_shift_con_weights", "modulename": "pose.nengo_utils", "qualname": "get_shift_con_weights", "kind": "function", "doc": "<p>Computes the weight matrix for the shift connection.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>tran_shift:</strong>  Shift value indicating how far the weights should be shifted along the preferred</li>\n<li>direction of the individual z-planes.</li>\n<li><strong>frec_con_weights:</strong>  Fourier coefficient vector of the non-transposed rec_con_weights.</li>\n<li><strong>rec_con_weights:</strong>  Final transposed rec_con_weights to be subtracted from the weight matrices</li>\n<li>to counteract the rec_con_weights when shifting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Weight matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tran_shift</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">frec_con_weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">rec_con_weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.get_rot_con_weights", "modulename": "pose.nengo_utils", "qualname": "get_rot_con_weights", "kind": "function", "doc": "<p>Computes the weight matrices for the CW+CCW rotation connections.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>rot_shift:</strong>  Shift value indicating how far up/down along the z-axis the weights should be</li>\n<li>shifted.</li>\n<li><strong>frec_con_weights:</strong>  Fourier coefficient vector of the non-transposed rec_con_weights.</li>\n<li><strong>rec_con_weights:</strong>  Final transposed rec_con_weights to be subtracted from the weight matrices</li>\n<li>to counteract the rec_con_weights when rotating.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>CW and CCW rotation weight matrices.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rot_shift</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">frec_con_weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">rec_con_weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.get_weights_optimized", "modulename": "pose.nengo_utils", "qualname": "get_weights_optimized", "kind": "function", "doc": "<p>Computes weight matrices for the recurrent attractor connection, shift connection, and CW+CCW\nrotation connections.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>weight_config:</strong>  Weight shape parameters, consisting of variance and factor of the excitatory</li>\n<li>and inhibitory Gaussian components, and an offset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Four weight matrices.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">weight_config</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.get_attractor_network", "modulename": "pose.nengo_utils", "qualname": "get_attractor_network", "kind": "function", "doc": "<p>Creates a Nengo ensemble and recurrent connection to obtain attractor dynamics.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ens_cfg:</strong>  Parameters for the ensemble, including encoders.</li>\n<li><strong>tau:</strong>  Synaptic time constant.</li>\n<li><strong>rec_con_weights:</strong>  Recurrent connection weights. May be sparse. If not specified, the weights</li>\n<li>are computed by Nengo based on the encoders. Defaults to None.</li>\n<li><strong>**kwargs:</strong>  Parameters for the wrapper network, e.g. label or seed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A Nengo network containing the recurrently connected attractor ensemble.</p>\n</blockquote>\n\n<h6 id=\"notes\">Notes:</h6>\n\n<blockquote>\n  <p>Specifies the block_shape config parameter for splitting the ensemble onto Loihi cores.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">ens_cfg</span><span class=\"p\">:</span> <span class=\"n\">nengo</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">Config</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">rec_con_weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.nengo_utils.get_pose_network", "modulename": "pose.nengo_utils", "qualname": "get_pose_network", "kind": "function", "doc": "<p>Creates a Nengo network capable of performing path integration.</p>\n\n<p>Multiple pose (position+orientation) estimates can be sustained simultaneously. Persistent reset\ninput can inhibit any other existing bumps and establish a single new bump at a desired\nposition.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>grid_shape:</strong>  Shape of a unit cell of the neuron lattice.</li>\n<li><strong>fgrid_shape:</strong>  Shape of the discrete sampling grid for the FFT, and of the reciprocal grid.</li>\n<li><strong>cov:</strong>  Covariance matrix of the Gaussian bumps.</li>\n<li><strong>tau:</strong>  Synaptic time constant.</li>\n<li><strong>dt:</strong>  Simulation time step in seconds.</li>\n<li><strong>rec_con_weights:</strong>  Recurrent connection weights for the attractor ensemble. May be sparse. If</li>\n<li>not specified, the weights are computed by Nengo based on the encoders. Defaults to None.</li>\n<li><strong>shift_con_weights:</strong>  Connection weights for translation. May be sparse. If not specified, the</li>\n<li>translation module is omitted. Defaults to None.</li>\n<li><strong>rot_con_weights_pos:</strong>  Connection weights for CCW rotation. May be sparse. If not specified,</li>\n<li>the CCW rotation module is omitted. Defaults to None.</li>\n<li><strong>rot_con_weights_neg:</strong>  Connection weights for CW rotation. May be sparse. If not specified,</li>\n<li>the CW rotation module is omitted. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A Nengo network containing the desired components for an attractor network, potentially\n  capable of performing path integration (depending on the parameters).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fgrid_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">cov</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">tau</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">dt</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span>,</span><span class=\"param\">\t<span class=\"n\">rec_con_weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shift_con_weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">rot_con_weights_pos</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">rot_con_weights_neg</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">_config</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting", "modulename": "pose.plotting", "kind": "module", "doc": "<p>Generate static and interactive plots of various aspects of the project during development, for evaluation, or for the documentation.</p>\n\n<h6 id=\"note\">Note:</h6>\n\n<blockquote>\n  <p>Not part of the public API.</p>\n</blockquote>\n"}, {"fullname": "pose.plotting.plot_multi", "modulename": "pose.plotting", "qualname": "plot_multi", "kind": "function", "doc": "<p>Generate a summary plot for the specified attractor state.</p>\n\n<p>It contains a three-dimensional plot and projections along the x- and y-axis.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">data1</span>, </span><span class=\"param\"><span class=\"n\">th</span>, </span><span class=\"param\"><span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;coolwarm&#39;</span>, </span><span class=\"param\"><span class=\"n\">show_plots</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_gauss_evo", "modulename": "pose.plotting", "qualname": "plot_gauss_evo", "kind": "function", "doc": "<p>Generate summary plots of the attractor state for the specified time points.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">v</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">data1</span>, </span><span class=\"param\"><span class=\"n\">th_fact</span><span class=\"o\">=</span><span class=\"mf\">0.9</span>, </span><span class=\"param\"><span class=\"n\">time_points</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">show_plots</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_sim", "modulename": "pose.plotting", "qualname": "plot_sim", "kind": "function", "doc": "<p>Generate a summary plot for the specified attractor state.</p>\n\n<p>It contains a three-dimensional plot and projections along the x-, y-, and z-axis.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">time</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;coolwarm&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_pose_estimate_timeseries", "modulename": "pose.plotting", "qualname": "plot_pose_estimate_timeseries", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">trange</span>,</span><span class=\"param\">\t<span class=\"n\">naive_estimates</span>,</span><span class=\"param\">\t<span class=\"n\">multiscale_estimate</span>,</span><span class=\"param\">\t<span class=\"n\">sample_every</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span>,</span><span class=\"param\">\t<span class=\"n\">xlim</span>,</span><span class=\"param\">\t<span class=\"n\">ylim</span>,</span><span class=\"param\">\t<span class=\"n\">ylabel</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_velocity_repr_timeseries", "modulename": "pose.plotting", "qualname": "plot_velocity_repr_timeseries", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">velocity_repr</span>, </span><span class=\"param\"><span class=\"n\">sample_every</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">ylabel</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.scatter", "modulename": "pose.plotting", "qualname": "scatter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">color</span>, </span><span class=\"param\"><span class=\"n\">alpha_arr</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwarg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_stuff", "modulename": "pose.plotting", "qualname": "plot_stuff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value_arr</span>, </span><span class=\"param\"><span class=\"n\">coords_on_R_arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_stuff_alpha", "modulename": "pose.plotting", "qualname": "plot_stuff_alpha", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value_arr</span>, </span><span class=\"param\"><span class=\"n\">coords_on_R_arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_parallelogram", "modulename": "pose.plotting", "qualname": "plot_parallelogram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_hexagon", "modulename": "pose.plotting", "qualname": "plot_hexagon", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_square", "modulename": "pose.plotting", "qualname": "plot_square", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_square2", "modulename": "pose.plotting", "qualname": "plot_square2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_hex_grid", "modulename": "pose.plotting", "qualname": "plot_hex_grid", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">XX</span>, </span><span class=\"param\"><span class=\"n\">YY</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.update_interactive_plot_wrapper", "modulename": "pose.plotting", "qualname": "update_interactive_plot_wrapper", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fig</span>,</span><span class=\"param\">\t<span class=\"n\">axes</span>,</span><span class=\"param\">\t<span class=\"n\">XXX</span>,</span><span class=\"param\">\t<span class=\"n\">YYY</span>,</span><span class=\"param\">\t<span class=\"n\">ZZZ</span>,</span><span class=\"param\">\t<span class=\"n\">XX_zproj</span>,</span><span class=\"param\">\t<span class=\"n\">YY_zproj</span>,</span><span class=\"param\">\t<span class=\"n\">YY_xproj</span>,</span><span class=\"param\">\t<span class=\"n\">ZZ_xproj</span>,</span><span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">bump_centers</span>,</span><span class=\"param\">\t<span class=\"n\">sample_every</span>,</span><span class=\"param\">\t<span class=\"n\">trange_offset</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.update_interactive_plot", "modulename": "pose.plotting", "qualname": "update_interactive_plot", "kind": "function", "doc": "<p>Provides an interactive plot of the time evolution of the activity\npacket. Expects the data as ndarray of shape\n(timepoints, np.prod(resolution_shape)).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">sample_every</span>, </span><span class=\"param\"><span class=\"n\">trange_offset</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.update_interactive_plot_xproj", "modulename": "pose.plotting", "qualname": "update_interactive_plot_xproj", "kind": "function", "doc": "<p>Provides an interactive plot of the time evolution of the activity\npacket. Expects the data as ndarray of shape\n(timepoints, np.prod(resolution_shape)).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fig</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">sample_every</span>, </span><span class=\"param\"><span class=\"n\">trange_offset</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.update_interactive_plot_3d", "modulename": "pose.plotting", "qualname": "update_interactive_plot_3d", "kind": "function", "doc": "<p>Provides an interactive plot of the time evolution of the activity\npacket. Expects the data as ndarray of shape\n(timepoints, np.prod(resolution_shape)).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fig</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span>,</span><span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">bump_centers</span>,</span><span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"n\">Y</span>,</span><span class=\"param\">\t<span class=\"n\">Z</span>,</span><span class=\"param\">\t<span class=\"n\">sample_every</span>,</span><span class=\"param\">\t<span class=\"n\">trange_offset</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_timeseries", "modulename": "pose.plotting", "qualname": "plot_experiment_timeseries", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">_exp_info</span>,</span><span class=\"param\">\t<span class=\"n\">_config</span>,</span><span class=\"param\">\t<span class=\"n\">pose_gauss_estimate</span>,</span><span class=\"param\">\t<span class=\"n\">time_slice</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_input_phases", "modulename": "pose.plotting", "qualname": "plot_experiment_input_phases", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_exp_info</span>, </span><span class=\"param\"><span class=\"n\">_config</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.num", "modulename": "pose.plotting", "qualname": "num", "kind": "function", "doc": "<p>3.0 -> 3, 3.001000 -> 3.001 otherwise return s</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_xy", "modulename": "pose.plotting", "qualname": "plot_experiment_xy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_exp_info</span>, </span><span class=\"param\"><span class=\"n\">_config</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span>, </span><span class=\"param\"><span class=\"n\">time_slice</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_xy_trajectories", "modulename": "pose.plotting", "qualname": "plot_experiment_xy_trajectories", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">traj_target</span>, </span><span class=\"param\"><span class=\"n\">traj_actual</span>, </span><span class=\"param\"><span class=\"n\">start_time</span>, </span><span class=\"param\"><span class=\"n\">stop_time</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_xy_sliced", "modulename": "pose.plotting", "qualname": "plot_experiment_xy_sliced", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">_exp_info</span>,</span><span class=\"param\">\t<span class=\"n\">_config</span>,</span><span class=\"param\">\t<span class=\"n\">bump_centers</span>,</span><span class=\"param\">\t<span class=\"n\">label_text</span>,</span><span class=\"param\">\t<span class=\"n\">label_positions</span>,</span><span class=\"param\">\t<span class=\"n\">offset_from_data_start</span>,</span><span class=\"param\">\t<span class=\"n\">time_slice</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_orientation_over_time", "modulename": "pose.plotting", "qualname": "plot_experiment_orientation_over_time", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_exp_info</span>, </span><span class=\"param\"><span class=\"n\">_config</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span>, </span><span class=\"param\"><span class=\"n\">time_slice</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_bump_centers_timeseries", "modulename": "pose.plotting", "qualname": "plot_bump_centers_timeseries", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_bump_centers_timeseries_sliced", "modulename": "pose.plotting", "qualname": "plot_bump_centers_timeseries_sliced", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span>, </span><span class=\"param\"><span class=\"n\">color_slice_start</span>, </span><span class=\"param\"><span class=\"n\">color_slice_end</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_snapshot_reconstructed_xy", "modulename": "pose.plotting", "qualname": "plot_experiment_snapshot_reconstructed_xy", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid_shape</span>, </span><span class=\"param\"><span class=\"n\">pose_reconstructed</span>, </span><span class=\"param\"><span class=\"n\">bump_centers</span>, </span><span class=\"param\"><span class=\"n\">vmin</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">vmax</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_fourier_coefs_2d", "modulename": "pose.plotting", "qualname": "plot_fourier_coefs_2d", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ax_arr</span>, </span><span class=\"param\"><span class=\"n\">fc_arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_fourier_coefs_3d_multi", "modulename": "pose.plotting", "qualname": "plot_fourier_coefs_3d_multi", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">figtitle</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.plot_experiment_interactive", "modulename": "pose.plotting", "qualname": "plot_experiment_interactive", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">title</span>,</span><span class=\"param\">\t<span class=\"n\">sample_every</span>,</span><span class=\"param\">\t<span class=\"n\">simulation_duration</span>,</span><span class=\"param\">\t<span class=\"n\">XXX</span>,</span><span class=\"param\">\t<span class=\"n\">YYY</span>,</span><span class=\"param\">\t<span class=\"n\">ZZZ</span>,</span><span class=\"param\">\t<span class=\"n\">pose_reconstructed</span>,</span><span class=\"param\">\t<span class=\"n\">bump_centers</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">time_slice</span><span class=\"o\">=</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.setup_weights_plot", "modulename": "pose.plotting", "qualname": "setup_weights_plot", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">neuron_res</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.plotting.get_weights_plot", "modulename": "pose.plotting", "qualname": "get_weights_plot", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">popts</span>, </span><span class=\"param\"><span class=\"n\">labels</span>, </span><span class=\"param\"><span class=\"n\">neuron_res</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pose.typing", "modulename": "pose.typing", "kind": "module", "doc": "<p>Collect type aliases here.</p>\n"}, {"fullname": "pose.typing.GridShape", "modulename": "pose.typing", "qualname": "GridShape", "kind": "variable", "doc": "<p>Shape of a hexagonal grid with orthogonal third dimension.</p>\n", "default_value": " = tuple[int, int, int]"}, {"fullname": "exp", "modulename": "exp", "kind": "module", "doc": "<p>Set up Sacred and logging for running experiments. Define a default config.</p>\n"}, {"fullname": "exp.default_config", "modulename": "exp", "qualname": "default_config", "kind": "variable", "doc": "<p>Supported config parameters for simulation, with sensible defaults.</p>\n", "default_value": " = {&#x27;seed&#x27;: 0, &#x27;nengo_seed&#x27;: 0, &#x27;dt&#x27;: 0.001, &#x27;fgrid_shape&#x27;: (12, 12, 12), &#x27;grid_shape&#x27;: (12, 12, 12), &#x27;variance_pose&#x27;: 0.0025, &#x27;sample_every&#x27;: 0.1, &#x27;simulation_duration&#x27;: 0.0, &#x27;tau&#x27;: 0.1, &#x27;base_exp_id&#x27;: 0, &#x27;weights&#x27;: {&#x27;var_exc&#x27;: 0.0108485147, &#x27;var_inh&#x27;: 0.01084861, &#x27;fact_exc&#x27;: 1.00115141, &#x27;fact_inh&#x27;: 1.001155, &#x27;offset&#x27;: 0.0, &#x27;tran_shift&#x27;: 0.020833333333333332, &#x27;rot_shift&#x27;: 0.020833333333333332}, &#x27;weight_sparse_threshold&#x27;: 2.3e-05, &#x27;input&#x27;: [], &#x27;use_loihi&#x27;: False, &#x27;bias&#x27;: 0.968, &#x27;enable_noise&#x27;: False, &#x27;noise_std&#x27;: 0.0, &#x27;continuous_inhib&#x27;: True, &#x27;full_init_con&#x27;: True, &#x27;comment&#x27;: &#x27;&#x27;, &#x27;output_filename&#x27;: &#x27;sim_data&#x27;, &#x27;enable_status_mails&#x27;: False, &#x27;textid&#x27;: &#x27;&#x27;}"}, {"fullname": "exp.run", "modulename": "exp", "qualname": "run", "kind": "function", "doc": "<p>Gets called when running an experiment with Sacred.\nDelegates to <code>pose.experiments.run_experiment</code> and handles output data generated during simulation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_config</span>, </span><span class=\"param\"><span class=\"n\">_run</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();